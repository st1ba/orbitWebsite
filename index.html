<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Scene</title>
    

    <style>

        .loadingscreen{
            background-color : black;
            position: absolute;
            height: 100%;
             width: 100%;
            opacity:1;
        }

        .is-loaded{
            opacity: 0;
            transition-duration: 3s;
        }
    

        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        .arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 200px;
            background-color: grey;
            opacity: 0.5;
            cursor: pointer;
        }
        .left-arrow {
            left: 10px;
        }
        .right-arrow {
            right: 10px;
        }

        .arrow:hover {
        background-color: white;
        }

        .arrow:active {
            background-color:grey;
        }

        .arrow {
        transition: background-color 0.2s ease-out;
        }

        .centered {
            width: 100px;
            margin-left: auto;
            margin-right: auto;
        }
    </style>
</head>
<body>



    <div id="loadingscreen" class="loadingscreen">
        <div style="text-align : center; margin-top : 10%;">
        <img width=50%
        class="fit-picture"
        src="logo.png"
        alt="Grapefruit slice atop a pile of other slices" />
        </div>
    </div>

    <div id="container"></div>

    <div class="arrow left-arrow" onclick="changeObject(-1)" id="leftArrow"></div>
    <div class="arrow right-arrow" onclick="changeObject(1)" id="rightArrow"><h class="centered">O</h></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/23.1.1/tween.umd.js" integrity="sha512-J8rv5Qz++2kwDP7YUBqxm3LCtPXWghcqXvxPrLrk81E31eMA/tEAjKakXJJDQoy9tj+41+EDYDsD6Xc76lnT7w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
   <script>
        let scene, camera, renderer, satellite;
        let objects = [];
        let currentObjectIndex = 0;
        let isAnimating = false;
        const earthGroup = new THREE.Group();
        let planet = null;
        scene = new THREE.Scene();
        var elapsed = 0;

        const texture = new THREE.TextureLoader().load( "space.png" );
        const loader = new THREE.GLTFLoader();
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set( 1, 1 );
        scene.background = texture;
        var parent = new THREE.Object3D();


        let buffer,buffercolor;
        var raycaster = new THREE.Raycaster();
        var mouse = {
            x: 0,
            y: 0
        },
        INTERSECTED;


        init();
        animate();

        function init() {
  
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 4;
            camera.rotation.z = 0.3; // Inclinaison vers la droite

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);


            // Create planet
            


            const detail = 12;
            let planetGeometry = new THREE.IcosahedronGeometry(1, detail);
            let planetMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

            var earthTexture = new THREE.TextureLoader("earth_texture.jpg");
            material = new THREE.MeshPhongMaterial( {
    		map: new THREE.TextureLoader().load("earth_texture.jpg"),
            bumpMap: new THREE.TextureLoader("earth_bump.jpg"), 
            specularMap: new THREE.TextureLoader("earth_spec.jpg"),
            bumpScale:0.04

    } );

            planet = new THREE.Mesh(planetGeometry, material);
            earthGroup.add(planet);
            scene.add(earthGroup);

            const lightsMat = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load("earth_light.jpg"),
            blending: THREE.AdditiveBlending,
            });
            const lightsMesh = new THREE.Mesh(planetGeometry, lightsMat);
            earthGroup.add(lightsMesh);


            const cloudsMat = new THREE.MeshStandardMaterial({
            map: new THREE.TextureLoader().load("earth_cloudmap.jpg"),
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending,
            alphaMap: new THREE.TextureLoader().load("earth_cloudmaptrans.jpg"),
            //alphaTest: 0.1,
            });
            const cloudsMesh = new THREE.Mesh(planetGeometry, cloudsMat);
            cloudsMesh.scale.setScalar(1.01);
            earthGroup.add(cloudsMesh);
            // Colors for objects
            
            const fresnelMat = getFresnelMat();
            const glowMesh = new THREE.Mesh(planetGeometry, fresnelMat);
            glowMesh.scale.setScalar(1.01);
            earthGroup.add(glowMesh);
            
            let colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];

            // Create objects orbiting around the planet
            for (let i = 0; i < 4; i++) {
                
                let geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                let material = new THREE.MeshBasicMaterial({ color: colors[i] });
                let object = new THREE.Mesh(geometry, material); 
                if(i>2)
                {
                    loader.load('scene.gltf' ,function ( gltf ) {
                        gltf.scene.position.x = Math.cos(i * Math.PI / 2) * 3;
                        gltf.scene.position.z = Math.sin(i * Math.PI / 2) * 3;
                        gltf.scene.position.y = -0.2;
                        gltf.scene.scale.set(0.005,0.005,0.005)
                        objects.push(gltf.scene);
                        scene.add(gltf.scene);
                        
                }, undefined, function ( error ) {

                console.error( error );

            } );
                }
                else
                {
                object.position.x = Math.cos(i * Math.PI / 2) * 3;
                object.position.z = Math.sin(i * Math.PI / 2) * 3;
                objects.push(object);
                scene.add(object);
                }
            }

            let geometry = new THREE.IcosahedronGeometry(0.1, detail);
            let mat = new THREE.MeshPhongMaterial( {
    		map: new THREE.TextureLoader().load("moon_texture.jpg") } );
            satellite = new THREE.Mesh(geometry, mat);
            scene.add(satellite);


            const sunLight = new THREE.DirectionalLight(0xffffff);
            sunLight.position.set(-2, 0.5, 1.5);
            scene.add(sunLight);
		document.addEventListener('mousemove', onMouseMove);

        const manager = new THREE.LoadingManager( onload=function ( ) {document.getElementById('loadingscreen').classList.add('is-loaded');});
        
        
        }
        
	    function onMouseMove(event) {
            // Calculate camera position based on mouse position
            let mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            let mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            camera.position.x = mouseX * 0.25;
            camera.position.y = mouseY * 0.25;


            camera.lookAt(scene.position);
	        camera.rotation.z = 0.3;


              // create a Ray with origin at the mouse position
                //   and direction into the scene (camera direction)
                var mouse = new THREE.Vector2();
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

                var raycaster = new THREE.Raycaster();
                raycaster.setFromCamera( mouse, camera );
                var intersects = raycaster.intersectObjects(objects, false);
                
                if(intersects.length > 0) {

                    if (!intersects[0].object.originalColor) {
                    intersects[0].object.originalColor = intersects[0].object.material.color.clone();
                    }
                    console.log(intersects[0].object);
                    intersects[0].object.material.color.setHex( 0xff9a00 );
                } 
                else 
                {
                    objects.forEach(object => {
        if (object.originalColor) {
            object.material.color.copy(object.originalColor);
            delete object.originalColor; // Supprimez la propriété originalColor pour libérer la mémoire
        }
    });
                }
                
        }

        function animate() {
            requestAnimationFrame(animate);
            texture.offset.x = camera.position.x / 50; // Ajustez le décalage x selon vos besoins
            texture.offset.y = camera.position.y / 50; // Ajustez le décalage y selon vos besoins
            // Rotate objects slowly
            objects.forEach((object) => {
                object.rotation.y += 0.004;
            });

            satellite.position.x = objects[3].position.x + Math.sin(elapsed*2) * 0.6;
            satellite.position.z = objects[3].position.z + Math.cos(elapsed*2) * 0.6;
            satellite.position.y= -0.2 + Math.sin(elapsed*2) * 0.2;
            elapsed-=0.001;

            if (planet) {
            earthGroup.rotation.y += 0.002; // Par exemple, faire tourner la planète autour de son axe Y
            }


            // Update Tween.js
            TWEEN.update();

            // Render scene
            renderer.render(scene, camera);

        }

        function changeObject(direction) {
            if (isAnimating) return; // Exit function if animation is in progress
            isAnimating = true; // Set animation flag to true

            currentObjectIndex += direction;
            if (currentObjectIndex < 0) {
                currentObjectIndex = objects.length - 1;
            } else if (currentObjectIndex >= objects.length) {
                currentObjectIndex = 0;
            }

            // Create Tween animations for each object
            let targetPositions = [];
            objects.forEach((object, index) => {
                let targetX = Math.cos((index + currentObjectIndex) * Math.PI / 2) * 3;
                let targetZ = Math.sin((index + currentObjectIndex) * Math.PI / 2) * 3;
                targetPositions.push({ x: targetX, z: targetZ });

                new TWEEN.Tween(object.position)
                    .to({ x: targetX, z: targetZ }, 1000) // Duration: 1000 milliseconds (1 second)
                    .easing(TWEEN.Easing.Quadratic.Out) // Smooth transition
                    .onComplete(() => { }) // Animation complete callback
                    .start(); // Start the animation


                new TWEEN.Tween(camera.position)
                    .to({ z: camera.position.z +0.5 }, 600) // Duration: 1000 milliseconds (1 second)
                    .easing(TWEEN.Easing.Quadratic.Out) // Smooth transition
                    .onComplete(() => { 
                        new TWEEN.Tween(camera.position)
                        .to({ z: camera.position.z -0.5 }, 600) // Duration: 1000 milliseconds (1 second)
                        .easing(TWEEN.Easing.Quadratic.Out) // Smooth transition
                        .onComplete(() => { isAnimating = false; }) // Animation complete callback
                        .start(); // Start the animation
                    
                    
                    }) // Animation complete callback
                    .start(); // Start the animation
            

            });
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


function getFresnelMat({rimHex = 0x0088ff, facingHex = 0x000000} = {}) 
{
  const uniforms = {
    color1: { value: new THREE.Color(rimHex) },
    color2: { value: new THREE.Color(facingHex) },
    fresnelBias: { value: 0.1 },
    fresnelScale: { value: 1.0 },
    fresnelPower: { value: 4.0 },
  };
  const vs = `
  uniform float fresnelBias;
  uniform float fresnelScale;
  uniform float fresnelPower;
  
  varying float vReflectionFactor;
  
  void main() {
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
  
    vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );
  
    vec3 I = worldPosition.xyz - cameraPosition;
  
    vReflectionFactor = fresnelBias + fresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), fresnelPower );
  
    gl_Position = projectionMatrix * mvPosition;
  }
  `;
  const fs = `
  uniform vec3 color1;
  uniform vec3 color2;
  
  varying float vReflectionFactor;
  
  void main() {
    float f = clamp( vReflectionFactor, 0.0, 1.0 );
    gl_FragColor = vec4(mix(color2, color1, vec3(f)), f);
  }
  `;
  const fresnelMat = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vs,
    fragmentShader: fs,
    transparent: true,
    blending: THREE.AdditiveBlending,
    // wireframe: true,
  });
  return fresnelMat;
}

     
    </script>
</body>
</html>

